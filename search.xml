<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows10 下 subsystem 安装</title>
    <url>/2020/12/10/Computer_Science/Settings/3_subsystem/</url>
    <content><![CDATA[<p>往往常规安装 Linux subsystem 的时候会默认安装在 C 盘中且无法变更。下文为一个工具推荐，使 subsystem 可以装在指定位置。</p>
<a id="more"></a>
<ol>
<li>
<p>安装Chocolatey</p>
</li>
<li>
<p><code>choco install lxrunoffline</code></p>
</li>
<li>
<p>下载wsl镜像 the *.tar.gz image from: <span class="exturl" data-url="aHR0cHM6Ly9seHJ1bm9mZmxpbmUuYXBwaGIuY29tL2Rvd25sb2FkL1VidW50dUZyb21NUy8xNg==" title="https://lxrunoffline.apphb.com/download/UbuntuFromMS/16">https://lxrunoffline.apphb.com/download/UbuntuFromMS/16<i class="fa fa-external-link"></i></span></p>
</li>
<li>
<p>安装镜像e:\UbuntuSubsys\16.04.2-server-cloudimg-amd64-root.tar.gz 到 e:\UbuntuSubsys\Ubuntu16 命名为 Ub16</p>
</li>
</ol>
<p><code>LxRunOffline i -n Ub16 -d e:\UbuntuSubsys\Ubuntu16 -f E:\UbuntuSubsys\16.04.2-server-cloudimg-amd64-root.tar.gz -s</code></p>
<ol start="5">
<li>
<p>启动环境：<br />
<code>wsl</code> 或 <code>LxRunOffline r -n Ub16</code></p>
</li>
<li>
<p>转为wsl2 版本 <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAyMjc5MjI2Nw==" title="https://segmentfault.com/a/1190000022792267">教程<i class="fa fa-external-link"></i></span></p>
</li>
<li>
<p>xserver<br />
[教程】(<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDMzOTcxNjIvc2hvdy1tYXRwbG90bGliLXBsb3RzLWFuZC1vdGhlci1ndWktaW4tdWJ1bnR1LXdzbDEtd3NsMg==" title="https://stackoverflow.com/questions/43397162/show-matplotlib-plots-and-other-gui-in-ubuntu-wsl1-wsl2">https://stackoverflow.com/questions/43397162/show-matplotlib-plots-and-other-gui-in-ubuntu-wsl1-wsl2<i class="fa fa-external-link"></i></span>)</p>
</li>
</ol>
<p>UB16 的包冲突问题 UB18 没此问题，UB16 <span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy84MzQyNTQvc3RlYW0tbGliZ2wtZXJyb3Itbm8tbWF0Y2hpbmctZmJjb25maWdzLW9yLXZpc3VhbHMtZm91bmQtbGliZ2wtZXJyb3ItZmFpbGVkLXQ=" title="https://askubuntu.com/questions/834254/steam-libgl-error-no-matching-fbconfigs-or-visuals-found-libgl-error-failed-t">解法<i class="fa fa-external-link"></i></span></p>
<ol start="8">
<li>如果要升级到 Ubuntu 18 参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3liZXJjaXRpLmJpei9mYXEvaG93LXRvLXVwZ3JhZGUtdWJ1bnR1LTE2LTA0LXRvLTE4LTA0LWx0cy11c2luZy10ZXJtaW5hbC8=" title="https://www.cyberciti.biz/faq/how-to-upgrade-ubuntu-16-04-to-18-04-lts-using-terminal/">教程<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Settings</category>
      </categories>
  </entry>
  <entry>
    <title>Docker的部署及使用</title>
    <url>/2020/12/05/Computer_Science/Settings/2_docker/</url>
    <content><![CDATA[<p>Docker 的设计初衷是封装除内核外应用相关的完整的运行时环境，以便开发过程中保持环境一致性问题。对于进程封装隔离，在操作系统层面虚拟化。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<a id="more"></a>
<p>以下内容参考并精简自 <span class="exturl" data-url="aHR0cHM6Ly92dWVwcmVzcy5taXJyb3IuZG9ja2VyLXByYWN0aWNlLmNvbS8=" title="https://vuepress.mirror.docker-practice.com/">Docker — 从入门到实践<i class="fa fa-external-link"></i></span></p>
<h3 id="docker-与虚拟机的区别"><a class="markdownIt-Anchor" href="#docker-与虚拟机的区别"></a> Docker 与虚拟机的区别</h3>
<ul>
<li>虚拟机技术是虚拟出来一套硬件，并运行一套完整的操作系统</li>
<li>Docker 容器内的应用直接运行于宿主内核，不虚拟硬件，对系统资源利用率更高，其中 <code>Dockerfile</code> 提供镜像构建详细信息，利于运维团队理解运行所需具体环境。</li>
</ul>
<h3 id="docker-的基本概念"><a class="markdownIt-Anchor" href="#docker-的基本概念"></a> Docker 的基本概念</h3>
<ul>
<li>镜像（<code>Image</code>）：虚拟化的多层文件系统，且为层层创建，任何对前一层的删除只是标记删除，而非实际删除，故创建每层时尽量只保留需要的文件。</li>
<li>容器（<code>Container</code>）：相当于镜像所创建的实例，为镜像运行时的实体。运行时是进程，但与宿主进程是不同的命名空间(Namespace - Linux 系统对于系统资源进行隔离和虚拟化的特性)。注意：提倡不在容器存储层读写数据，容器只保留运行相关内容，而是使用数据卷 (Volume) 或者绑定宿主目录，以直接在宿主上进行读写，否则容器消失时容器存储也会消失，导致数据丢失。</li>
<li>仓库（<code>Repository</code>）：在 Docker Registry 下存储镜像的实体，其中可包含多个版本镜像，以不同 tag 标记 (<code>&lt;仓库名&gt;:&lt;标签&gt;</code>)。</li>
</ul>
<h3 id="docker-本地使用"><a class="markdownIt-Anchor" href="#docker-本地使用"></a> Docker 本地使用</h3>
<h4 id="1-windows-10-下"><a class="markdownIt-Anchor" href="#1-windows-10-下"></a> 1. Windows 10 下</h4>
<ul>
<li>依据 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm52aWRpYS5jb20vY3VkYS93c2wtdXNlci1ndWlkZS9pbmRleC5odG1s" title="https://docs.nvidia.com/cuda/wsl-user-guide/index.html">教程<i class="fa fa-external-link"></i></span> 安装 cuda toolkits (注意：看清 Windows 系统具体版本要求，看清各个指令中关于 ubuntu 和 cuda 的版本号，明确注明了不用Docker desktop，直接在 WSL2 中按照教程安装)</li>
<li>依据 <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAyMjc5MjI2Nw==" title="https://segmentfault.com/a/1190000022792267">教程<i class="fa fa-external-link"></i></span> 安装 Windows10 下 Linux 子系统服务 WSL2 并激活</li>
</ul>
<p>Gibson</p>
<ol>
<li>在 wsl2 上安装 xhost</li>
</ol>
<blockquote>
<p>apt install x11-xserver-utils</p>
</blockquote>
<ol start="2">
<li></li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Settings</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo框架调试步骤简介</title>
    <url>/2020/12/05/Computer_Science/Programming_Skill/4_hexo/</url>
    <content><![CDATA[<p>本文主要针对hexo博客框架的基础预览和部署流程</p>
<a id="more"></a>
<hr>
<h3 id="指令hexo后命令缩写"><a class="markdownIt-Anchor" href="#指令hexo后命令缩写"></a> 指令<code>hexo</code>后命令缩写</h3>
<table>
<thead>
<tr>
<th>Option</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>clean</td>
<td style="text-align:center">clean cache files</td>
</tr>
<tr>
<td>generate, g</td>
<td style="text-align:center">generate code</td>
</tr>
<tr>
<td>deploy, d</td>
<td style="text-align:center">deploy generated code</td>
</tr>
</tbody>
</table>
<p>更多请参考 <a href="'https://hexo.io/docs/commands.html'">官方文档</a></p>
<h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3>
<p>保存更改后，以下指令清缓存生成网页文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>启动local server默认在<code>http://localhost:4000/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>一般来说启动local server后再更改文件依旧会生效，如果未生效（比如更改了主要的<code>_config.yml</code>），请手动重新走一遍流程。</p>
<h3 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Programming Skill</category>
      </categories>
  </entry>
  <entry>
    <title>一些常用的debug技巧</title>
    <url>/2020/03/06/Computer_Science/Programming_Skill/3_debug/</url>
    <content><![CDATA[<p>This blog based on my note studying Lecture 7 of MIT course “Missing Semester of your CS”. Which is about the debugging strategies.</p>
<a id="more"></a>
<hr>
<h2 id="log-记录程序运行问题"><a class="markdownIt-Anchor" href="#log-记录程序运行问题"></a> log 记录程序运行问题</h2>
<p>首先，Unix系统下会有个 <code>/var/log</code> 文件夹，存放系统相关的 log，比如 <code>system.log</code>，可以通过以下指令查看该文件的内容，<code>--last</code> 查看多久范围的 <code>system.log</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span> show --last 10s</span><br></pre></td></tr></table></figure>
<h2 id="profile"><a class="markdownIt-Anchor" href="#profile"></a> profile</h2>
<p>profile 用于记录不同代码段的运行时间，调用次数等信息，两个工具可以做到这一点。这一节主要以 python 程序为例。</p>
<h3 id="cprofile"><a class="markdownIt-Anchor" href="#cprofile"></a> cProfile</h3>
<p>第一个用 python 本身带的模式 <code>cProfile</code>，可以在命令中加入，其中 <code>tac</code> 用于反向输出，更符合阅读习惯。向下滚动命令行会看到占用时间越来越多的代码段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m cProfile -s tottime example.py | tac</span><br></pre></td></tr></table></figure>
<h3 id="line-profiler"><a class="markdownIt-Anchor" href="#line-profiler"></a> line profiler</h3>
<p>另一个比较好的软件是 <mark><strong>line_profiler</strong></mark> 可以显示代码每行所占用的运行时间比例。只需要在想要 profile 的子函数前加 <code>@profile</code> 即可。</p>
<p>我们可以通过 pip 安装 profiler</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install line_profiler</span><br></pre></td></tr></table></figure>
<p>在代码中加入 <code>@profile</code> 后，通过以下指令运行 python 程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kernprof -l -v example.py</span><br></pre></td></tr></table></figure>
<p>通过以下代码还可以查看代码的 memory 使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m memory_profiler example.py</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Programming Skill</category>
      </categories>
  </entry>
  <entry>
    <title>Shell 的使用</title>
    <url>/2020/03/05/Computer_Science/Programming_Skill/0_Shell/</url>
    <content><![CDATA[<p>This blog based on my note studying Lecture 1,2,5 of MIT course “Missing Semester of your CS”. Which is about the useage of Shell.</p>
<a id="more"></a>
<hr>
<h2 id="shell-命令"><a class="markdownIt-Anchor" href="#shell-命令"></a> Shell 命令</h2>
<h3 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h3>
<p>$PATH  — means environment variables, so you can echo $PATH to see all the directories added to $PATH</p>
<h3 id="directory-有关命令"><a class="markdownIt-Anchor" href="#directory-有关命令"></a> directory 有关命令</h3>
<p><code>pwd</code> — means print working directory</p>
<p><code>which python</code> — means if application python is added in environment, print its directory</p>
<h3 id="cd-命令"><a class="markdownIt-Anchor" href="#cd-命令"></a> cd 命令</h3>
<p><code>cd -</code> — means enter the previous directory</p>
<h3 id="ls-命令"><a class="markdownIt-Anchor" href="#ls-命令"></a> ls 命令</h3>
<p>当使用 <code>ls -l</code> 命令时，第一个部分每三个字节代表一个层级的用户的访问权限 <br><br />
例如: <code>-rwxr-xr-x</code> root可以读取写入和执行，第一个rwx是owner的权限，r-w是group的权限，最后一个r-w是其他人的权限</p>
<p>对于文件权限<br><br />
<code>r</code> — read      可以用打开文件 <br><br />
<code>w</code> — write     可以修改该文件 <br><br />
<code>x</code> — execute   可以运行该文件</p>
<p>对于文件夹权限<br><br />
<code>r</code> — read      可以用ls来看文件夹内的文件<br><br />
<code>w</code> — write     可以修改该文件夹<br><br />
<code>x</code> — execute   可以cd进入这个文件夹</p>
<p><code>chmod</code> — 修改文件(夹)权限 <br><br />
e.g. <code>chmod -R -w foldername</code> 其中 <code>-R</code> 等价于 <code>--recursive</code> 用于递归的修改文件夹及内部所有内容的权限，<code>-w</code> 为删除 write 权限，<code>+w</code> 为增加 write 权限。</p>
<h3 id="文件夹和文件的基本操作"><a class="markdownIt-Anchor" href="#文件夹和文件的基本操作"></a> 文件夹和文件的基本操作</h3>
<p><code>mv dir1 dir2</code>— rename/move <br><br />
<code>rm file</code> — remove file <br><br />
<code>rmdir</code> — remove directory <br><br />
<code>mkdir</code> — create directory <br><br />
<code>cat file</code> — print the content of a file <br></p>
<p><code>find dir -name filename -type filetype</code> — 在dir下找match filename的所有文件(type f)或文件夹(type d) <br><br />
<mark>Tricks</mark>：<br></p>
<ol>
<li>自定义查找，可以用-path属性结合formatable string，例如<br />
<code>find ./project -path '**/test/*.py' -type f</code> <br><br />
用于查找project目录下的所有文件夹下test下的py文件<br></li>
<li>可以在查找结果中通过 <code>-exec</code> 属性直接对找到的文件操作，例如<br />
<code>find ./project -name &quot;*.tmp&quot; -exec rm &#123;&#125; \;</code> <br><br />
删除所有tmp文件，其中;指的结束rm这一条指令，相当于回车符</li>
</ol>
<p><code>rg string -t py -C 5 dir</code> — 在dir下所有py结尾的文件夹中查找string并返回其5行的context内容  （rg 为加强版的grep全称为ripgrep）<br></p>
<p><code>touch</code> — 修改文件时间戳，创建文件 <br><br />
<mark>Tricks</mark>：<br></p>
<ul>
<li>比如要创建test1 test2 test3三个文件<br />
则利用shell自带的拓展语法{ , , , }即可<br />
<code>touch test&#123;1,2,3&#125;</code></li>
</ul>
<h3 id="关于一些program的基本shell端指令"><a class="markdownIt-Anchor" href="#关于一些program的基本shell端指令"></a> 关于一些program的基本shell端指令</h3>
<p><code>man app</code> — show the program menu 一般即是 --help 的内容 <br><br />
<code>tldr app</code> — show examples of how to use this app <br><br />
<code>left | right</code> — output of left program to be the input of right program <br><br />
<code>sudo</code> — do as super user</p>
<h3 id="shell-上的一些快捷操作"><a class="markdownIt-Anchor" href="#shell-上的一些快捷操作"></a> Shell 上的一些快捷操作</h3>
<p>快捷键 <code>ctrl+l</code> — 清空shell <br><br />
快捷键 <code>ctrl+r</code> — 在shell的history中开搜索框 <br><br />
<code>history</code> — recent command history <br><br />
<code>history 1</code> — 所有command的history <br><br />
<code>history 1 | grep string</code> — 在所有history中找到匹配string的指令 <br><br />
<code>tree</code> — 文件夹构成 <br><br />
<code>broot</code> — 增强版tree，会折叠部分信息，支持文件搜索功能 <br><br />
<code>nnn</code> — 增强版tree，支持快速进入不同的directory</p>
<hr>
<h2 id="bash-程序"><a class="markdownIt-Anchor" href="#bash-程序"></a> Bash 程序</h2>
<h3 id="文件头声明"><a class="markdownIt-Anchor" href="#文件头声明"></a> 文件头声明</h3>
<p>在 <code>.sh</code> 文件前声明 <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>指该文件是由bash解释器运行的命令程序<br><br />
<mark>Tricks</mark>：<br><br />
python文件也可以通过解释器声明以直接运行，而不用在命令行打python3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!#&#x2F;usr&#x2F;bin&#x2F;env python3</span><br></pre></td></tr></table></figure>
<p>操作系统会根据env下python3的安装路径找到python3解释器</p>
<h3 id="bash-程序变量"><a class="markdownIt-Anchor" href="#bash-程序变量"></a> bash 程序变量</h3>
<p>变量由 <code>$var_name</code> 表示 <br><br />
<code>$+数字</code> — 代表输入字符串的第几个string的内容 <code>$0</code> 是第一个string <br><br />
<code>$(pwd)</code> — pwd命令执行后的返回的string内容</p>
<h3 id="样例程序"><a class="markdownIt-Anchor" href="#样例程序"></a> 样例程序</h3>
<p>example code 写在 <code>example.sh</code> 下<br />
该程序用于在多个文件中找foobar这个词，如果没有就添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历$1到$n每个文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">    grep foobar <span class="variable">$file</span> &gt; /dev/null 2&gt; /dev/null <span class="comment"># grep is used for search a word in file</span></span><br><span class="line">    <span class="comment"># When pattern is not found, grep has exit status 1</span></span><br><span class="line">    <span class="comment"># We redirect STDOUT and STDERR to a null register since we do not care about them</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># -ne &#x27;means not equal to&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>示例运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./example.sh hello.py a.sh b.txt</span><br></pre></td></tr></table></figure>
<p>即在 <code>hello.py a.sh b.txt</code> 三个文件中查找foobar，如果没有就添加</p>
<h2 id="tmux-终端复用软件"><a class="markdownIt-Anchor" href="#tmux-终端复用软件"></a> tmux 终端复用软件</h2>
<p>是 screen 的升级版，可以更有效的分隔创建 terminal</p>
<p>可参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaGFtdm9ja2UuY29tL2Jsb2cvYS1xdWljay1hbmQtZWFzeS1ndWlkZS10by10bXV4Lw==" title="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">tmux tutorial<i class="fa fa-external-link"></i></span></p>
<h2 id="alias-用于定义一段command的简称"><a class="markdownIt-Anchor" href="#alias-用于定义一段command的简称"></a> alias 用于定义一段command的简称</h2>
<p>在 <code>~/.bashrc</code> 中添加以下代码，则可输入 <code>gs</code> 以执行 <code>git status</code> 指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> gs=<span class="string">&quot;git status&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Programming Skill</category>
      </categories>
  </entry>
  <entry>
    <title>git 版本控制</title>
    <url>/2020/03/05/Computer_Science/Programming_Skill/2_git/</url>
    <content><![CDATA[<p>This blog based on my note studying Lecture 6 of MIT course “Missing Semester of your CS”. Which is about the useage of git for version control.</p>
<a id="more"></a>
<hr>
<h2 id="查询git信息的指令"><a class="markdownIt-Anchor" href="#查询git信息的指令"></a> 查询git信息的指令</h2>
<p><code>git init</code> 用于在当前文件夹下创建git有关的记录文件，成为一个repository</p>
<p><code>git log --all --graph --decorate</code> 用于看这个repository的commit graph，现在所处的版本会在graph中标记为 <code>HEAD</code>。如果需要精简版，可以加入属性 <code>--oneline</code>。</p>
<p><code>git status</code> 用于查看将会被 commit 的文件列表 (通过 <code>git add</code> 会显示为 tracked)</p>
<p><code>git show commit_id</code> 可以看某一次 commit 的提交信息和改动的地方</p>
<hr>
<h2 id="为什么需要先-git-add-而不直接设计成一键更新"><a class="markdownIt-Anchor" href="#为什么需要先-git-add-而不直接设计成一键更新"></a> 为什么需要先 <code>git add</code> 而不直接设计成一键更新</h2>
<p>首先，通过 <code>git add file1</code> 向git的管理系统声明 <strong>file1</strong> 是有先后的意义，也就是说如果之后又有 <code>git add file2</code> 则 <strong>file2</strong> 在历史记录中会在 <strong>file1</strong> 之后出现，先 <code>git add</code> 再整体 <code>git commit</code> 的设计可以体现这种文件出现的先后顺序。</p>
<p>其次，对于许多的编程语言编译时会在当前文件夹产生非代码的编译文件，这些很多时候是在提交代码时不需要的。如果每次都把文件夹内容全部 <code>commit</code>，则不可避免会记录这些次要文件的改动。</p>
<p><mark>Note</mark>: 对于commit的subject，使用祈使句，字数少于 50。</p>
<hr>
<h2 id="过去内容的访问和回溯"><a class="markdownIt-Anchor" href="#过去内容的访问和回溯"></a> 过去内容的访问和回溯</h2>
<p><code>git checkout commit_id</code> 在 <code>commit_id</code> 部分填入想要访问的过去版本的commit的id，当前文件夹的内容会变成过去的版本。通过 <code>git checkout master</code> 可回到现在的版本。</p>
<p><code>git diff commit_id file_1</code> 可以比较当前版本与 <code>commit_id</code> 版本 <code>file_1</code> 文件的改变。</p>
<p><code>git diff commit_id commit_id2 file_1</code> 可以比较 <code>commit_id2</code>版本在 <code>commit_id</code> 版本基础上 <code>file_1</code> 文件的改变。</p>
<p><code>git reset --hard commit_id</code> 回退到 <code>commit_id</code> 的版本</p>
<p>如果想回到回退前的版本，需要以下两步 <br></p>
<ul>
<li><code>git reflog</code> 查看 reset 等操作的历史，找到操作的id</li>
<li><code>git reset --hard ref_id</code> 回退到回退前的状态</li>
</ul>
<h2 id="在git中创建和整合分支"><a class="markdownIt-Anchor" href="#在git中创建和整合分支"></a> 在git中创建和整合分支</h2>
<p><code>git branch</code> 可以显示当前有哪些分支</p>
<p><code>git branch branch_name</code> 在 <code>branch_name</code> 中输入新名字，则会在当前版本下创建新分支。</p>
<p><code>git checkout branch_name</code> 可以跳转到 <code>branch_name</code> 分支</p>
<p><code>git merge branch_name</code> 可以把 <code>branch_name</code> 分支整合入当前版本当前分支。如果发生内容冲突，git会提示哪个文件出现了冲突。修改文件保存后，重新 <code>git add file_conflict</code>， 然后 <code>git merge --continue</code> 以继续进行 merge。</p>
<h2 id="在git中连接远程的另一个repository"><a class="markdownIt-Anchor" href="#在git中连接远程的另一个repository"></a> 在git中连接远程的另一个repository</h2>
<p><code>git remote add origin https://github.com/user_name/repository_name.git</code> 命名远端repository为 <code>origin</code></p>
<p><code>git push origin local_branch_name:remote_branch_name</code> 用于上传更新到远端</p>
<p><mark>Tricks</mark> <br><br />
为了简化上传操作，可以先把 local 和 remote 的 branch 声明有关 <br><br />
<code>git branch --set-upstream-to=origin/remote_branch_name</code> <br><br />
之后只需 <code>git push</code> 即可更新远端。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Programming Skill</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 编辑器的使用</title>
    <url>/2020/03/04/Computer_Science/Programming_Skill/1_Vim/</url>
    <content><![CDATA[<p>This blog based on my note studying Lecture 3 of MIT course “Missing Semester of your CS”. Which is about the useage of Vim Editor.</p>
<a id="more"></a>
<h3 id="normal-mode-in-any-other-mode-press-esc"><a class="markdownIt-Anchor" href="#normal-mode-in-any-other-mode-press-esc"></a> Normal mode (in any other mode, press <code>esc</code>)</h3>
<p>Normal mode is designed for nevigating the content of the document and make small changes in the file.</p>
<h4 id="nevigation"><a class="markdownIt-Anchor" href="#nevigation"></a> Nevigation</h4>
<p><code>h/j/k/l</code> cursor move (left, down, up, right)</p>
<p><code>w/b</code> cursor move one word (forward (next), backward (last))</p>
<p><code>e</code> cursor move to end of the word</p>
<p><code>0/^/$</code> cursor move to (beginning, beginning charactor, end) of a line</p>
<p><code>&lt;C-u&gt;</code>/<code>&lt;C-d&gt;</code> cursor move (up, down) half page</p>
<p><code>gg</code>/<code>G</code> cursor move to (beginning, end) of file</p>
<p><code>HML</code> cursor move to (Highest, Middle, Lowest) line of current page</p>
<p><code>f + any charactor</code> cursor move forward (next) to find first (any charactor)</p>
<p><code>F + any charactor</code> cursor move backward (last) to find the last (any charactor)</p>
<p><code>h</code> hovering over different group (group by brackets), match the first group sign (left bracket).</p>
<p><code>%</code> cursor jump back and forth between matching brackets</p>
<blockquote>
<p>Most nevigation key can combine with numbers for constant number of steps of move. e.g. 4k means press k for 4 times.</p>
</blockquote>
<h4 id="small-editing"><a class="markdownIt-Anchor" href="#small-editing"></a> Small editing</h4>
<p><code>o</code> create a new line under the cursor and go into insert mode</p>
<p><code>O</code> create a new line above the cursor and go into insert mode</p>
<p><code>d+w</code> delete a word</p>
<p><code>d+e</code> delete content from the cursor to the end of this word</p>
<p><code>c+w</code> == <code>d+w</code> + <code>i</code> means change one word</p>
<p><code>c+e</code> == <code>d+e``` +</code>i`</p>
<p><code>dd</code> delete a line</p>
<p><code>cc</code> == <code>dd</code> + <code>i</code></p>
<p><code>x</code> delete the charactor where cursor is</p>
<p><code>r + any charactor</code> replace the charactor by (any charactor)</p>
<p><code>yy</code> copy current line</p>
<p><code>yw</code> copy a word</p>
<p><code>p</code> paste</p>
<p><code>.</code> repeat previous editing command. e.g. insert a word in the insert mode, <code>esc</code> and move to another place press <code>.</code>, it will repeat insert that word in current place.</p>
<blockquote>
<p>Note: Always combine with visual mode, select a region and press <code>y</code> for copy</p>
</blockquote>
<p><code>u</code> undo</p>
<h4 id="modifiers"><a class="markdownIt-Anchor" href="#modifiers"></a> Modifiers</h4>
<p><code>i</code> means ‘inside’, combine with other command. e.g. <code>ci[</code> means change content inside bracket [ ].</p>
<p><code>a</code> means ‘around’, combine with other command. e.g. <code>da(</code> means delete content inside and including the bracket ( ).</p>
<h3 id="insert-mode"><a class="markdownIt-Anchor" href="#insert-mode"></a> Insert mode</h3>
<p>In the normal mode:</p>
<p>press <code>i</code> to enter insert mode and place the cursor <mark>before</mark> current charactor (insert)</p>
<p>press <code>a</code> to enter insert mode and place the cursor <mark>after</mark> current charactor (append)</p>
<h3 id="replace-mode-press-r-in-normal-mode"><a class="markdownIt-Anchor" href="#replace-mode-press-r-in-normal-mode"></a> Replace mode (press <code>r</code> in normal mode)</h3>
<h3 id="visual-mode"><a class="markdownIt-Anchor" href="#visual-mode"></a> Visual mode</h3>
<p>From normal mode, you can either:</p>
<ul>
<li>press <code>v</code> to go into visual mode</li>
<li>press <code>V</code> to go into visual line mode</li>
<li>press <code>&lt;C-v&gt;</code> to go into visual block mode (rectangular block)</li>
</ul>
<p>Use the same keys as normal mode to quickly move cursor for quick selection.</p>
<h3 id="command-line-mode"><a class="markdownIt-Anchor" href="#command-line-mode"></a> Command-line mode</h3>
<p>In the normal mode, several key will start the command mode, <code>:</code> for common setting, <code>/</code> for search</p>
<p><code>:w</code> save file</p>
<p><code>:q</code> close file</p>
<p><code>:!q</code> close file without saving</p>
<p><code>/hello</code> search word ‘hello’, press <code>Enter</code> move to the returned result</p>
<p><code>:10</code> means jump to line 10</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Programming Skill</category>
      </categories>
  </entry>
  <entry>
    <title>Legal High 开篇，重新审视自己的信仰</title>
    <url>/2020/02/23/film-review/Legal_High/ep1/</url>
    <content><![CDATA[<p>Legal High 前三集讲述了新人律师黛真知子因为一起刑事辩护，与古美门律师相识之后的三个案件。如果说第一个案件让黛真知子第一次对律师职业的本质产生疑问，那么后两个案件让她理解了各行内部的或许不光彩但又无法撼动的内在规律。</p>
<a id="more"></a>
<p>第一个案件，古美门和黛找到检方漏洞，以检方证据不足为由，帮助嫌疑人摆脱故意杀人的嫌疑。这个时候的黛刚走出校门，心怀理想主义，警方对于嫌疑人的刑讯逼供轻易的使她站在了嫌疑人一方。当她以为最终凭自己的努力帮嫌疑人摆脱冤情，嫌疑人走出法院后所暴露出的恶毒本性让她对自己的所做产生了质疑，觉得自己或许掩盖了真相。古美门告诉她，律师不是神，不可能知道真相是什么，嫌疑人被释放是因为证据不足，并不是她的错，律师的责任只是在法律框架下为委托人提供帮助，仅此而已。这番话使她决定跟随古美门，在更多的实际案件中，思考自己到底信仰什么。</p>
<p>第二个案件是一个作品剽窃案。其中揭示了音乐商业中广泛的代笔行为和光环效应。在商业的大环境下，造神不可避免，这仿佛成为了传播作品的捷径。被推到台前的神通过其商业价值养活着一个个其背后真实的创作者，品牌效应又会带来更大的利润。随即产生了投机者，他们有恃无恐的剽窃着产业链外的独立创作者，由于产业链内部的强利益关系，品牌团队也不得不保护这些投机者以免打破好不容易创造的神话。但令人振奋的是，在这个案件中，黛真知子看到了这个世界上还是有那些勇敢的独立创作者敢于与一个商业帝国对抗，甚至不为金钱，只为了一个尊重。。</p>
<p>第三个案件有两分支，古美门在他接到的案件中帮助爆粗口老太太敲诈了棒球俱乐部一大笔钱，这也算古美门第一次给黛展示了如何利用行业内潜在规律，取得最终的辩护胜利。他使用了诸如对法官的背景详细搜集并对症下药，以及诱导式取证。黛接到了一个关于跟踪狂抢亲的案件。在调查取证的过程中，她发现人的感情在利益面前还是那么脆弱。被贴上跟踪狂标签的委托人和黛大学时期那么的像，天真的以为感情寄托的对象也会重情重义，一尘不染。现实却总是一次次的打脸。我很欣赏委托人最后阻止黛拿出帮他脱罪的关键证据的那个举动，他知道这个画像意味着女原告并不是没有感情，只是迫于现实要下决心摆脱之前的一切，她内心一定饱受折磨。委托人不愿意在最后这个分别的法庭上，再去困扰她。黛真知子也在这个法庭上，在和她之前喜欢的渣男教授的对辩中，告别了过去那个天真但又脆弱的自己。</p>
<p>以上三个案件只是Legal High这部无比精彩的作品的一个小小的开场。黛真知子和古美门价值观的分歧也在逐渐清晰。黛认为律师的职责在于引导法官看到事件真相，输赢不是一切，而古美门则认为律师永远无法看到真相，相较于缥缈的正义感，通过法律帮委托人赢得诉讼才是律师的责任。那么，我支持哪一方呢？至少目前的我还没有答案。</p>
]]></content>
      <categories>
        <category>Film Review</category>
        <category>Legal High</category>
      </categories>
  </entry>
  <entry>
    <title>Online Judge 基本代码框架</title>
    <url>/2020/02/23/Computer_Science/Settings/1_Contest_framework/</url>
    <content><![CDATA[<p>编程竞赛一般的模式是常规在本地测试，然后上传代码提交。故标准化本地调试的配置会有事半功倍的效果。这一篇博客主要是我在学习了Codeforces排名前列的前辈们的代码后，总结出的比较规范的代码框架和一些注意事项。解决这些可能拖慢节奏的小问题，我们就可以愉快的解题了！</p>
<a id="more"></a>
<h2 id="通用代码结构"><a class="markdownIt-Anchor" href="#通用代码结构"></a> 通用代码结构</h2>
<p>通过preprocessor option的方式<br />
1. 重定向input/output文件<br />
2. 计算代码块的运行时间</p>
<p><strong>Linux系统：</strong> 在g++指令中只需要加 <code>-DLOCAL_RUN</code> 作为预处理器指令即可。</p>
<p><strong>Windows系统：</strong> 在<strong>Visual Studio</strong>中找到项目属性，选择Preprocessor，在Preprocessor Definition里点击Edit，添加 <code>LOCAL_RUN</code> 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt; // for time spend</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // redirect input/output file</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> ll LINF = (ll)<span class="number">2e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL_RUN</span></span><br><span class="line">    freopen(<span class="string">&quot;test.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;test.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">auto</span> start = chrono::high_resolution_clock::now();</span><br><span class="line">  run();</span><br><span class="line">  <span class="keyword">auto</span> end = chrono::high_resolution_clock::now();</span><br><span class="line">	</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL_RUN</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Execution time: &quot;</span></span><br><span class="line">      &lt;&lt; chrono::duration_cast&lt;chrono::milliseconds&gt;(end - start).count()</span><br><span class="line">      &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="visual-studio-必要初始设置"><a class="markdownIt-Anchor" href="#visual-studio-必要初始设置"></a> Visual Studio 必要初始设置</h2>
<ol>
<li>创建empty C++ project</li>
<li>如果出现printf等安全性警告，可：</li>
</ol>
<blockquote>
<p>在Solution Explorer中右键项目名 -&gt; properties -&gt; C/C++ -&gt; SDL checks更改为No</p>
</blockquote>
<h2 id="另一种替代stdin和stdout的手段-命令行"><a class="markdownIt-Anchor" href="#另一种替代stdin和stdout的手段-命令行"></a> 另一种替代stdin和stdout的手段-命令行</h2>
<p><strong>Linux系统：</strong> 创建 bash 运行文件 <code>run.sh</code> 并写入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -Wall -Wshadow -std=c++11 main.cpp -o projectname</span><br><span class="line">./projectname &lt; test.in &gt; test.out</span><br></pre></td></tr></table></figure>
<p>通过 <code>bash run.sh</code> 编译并运行代码。</p>
<p><strong>Windows系统：</strong> 在 <strong>Visual Studio</strong> 的项目属性下的 Debugging 选项卡下找到 Command Arguments，输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; &quot;$(ProjectDir)test.in&quot; &gt;&quot;$(ProjectDir)test.out&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Science</category>
        <category>General Settings</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 编辑器的基本配置</title>
    <url>/2020/02/23/Computer_Science/Settings/0_Vim_setting/</url>
    <content><![CDATA[<h3 id="配置vim编辑器"><a class="markdownIt-Anchor" href="#配置vim编辑器"></a> 配置Vim编辑器</h3>
<p>在<code>.vimrc</code>文件中写入以下配置信息：</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax on          <span class="string">&quot; open syntax color for languages</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set tabstop=2      &quot;</span> The width of a TAB is <span class="built_in">set</span> to 2</span><br><span class="line"><span class="built_in">set</span> shiftwidth=2   <span class="string">&quot; Indents will have a width of 2</span></span><br><span class="line"><span class="string">set expandtab      &quot;</span> Expand TABs to spaces</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;backspace to delete one level of indent</span></span><br><span class="line"><span class="string">set backspace=indent,eol,start </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set number         &quot;</span> open line number</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> hlsearch       <span class="string">&quot; open highlight pattern</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">colorscheme molokai</span></span><br><span class="line"><span class="string">&quot;</span>colorscheme solarized</span><br></pre></td></tr></table></figure>
<h3 id="vim-常用快捷键"><a class="markdownIt-Anchor" href="#vim-常用快捷键"></a> Vim 常用快捷键</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kZGU3N2UzYjI5OWY=" title="https://www.jianshu.com/p/dde77e3b299f">参考1<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82ODExMTQ3MQ==" title="https://zhuanlan.zhihu.com/p/68111471">参考2<i class="fa fa-external-link"></i></span></p>
<h3 id="编译运行重定向标准输入和输出"><a class="markdownIt-Anchor" href="#编译运行重定向标准输入和输出"></a> 编译运行（重定向标准输入和输出）</h3>
<p>竞赛中常把标准输入和标准输出分开，并尽可能从文件中读取输入。这里可把这些操作综合在一个<code>run.sh</code>文件中一步运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -Wall -Wshadow -std=c++11 main.cpp -o projectname</span><br><span class="line">./projectname &lt; test.in &gt; test.out</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Science</category>
        <category>General Settings</category>
      </categories>
  </entry>
</search>
